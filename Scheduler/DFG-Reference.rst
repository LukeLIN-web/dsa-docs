Dataflow Graph Syntax Reference
================================

The Dataflow Graph (DFG) is a representation of the dataflow of a program. It is a directed graph where the nodes are the operations and the edges are the data dependencies between the operations. The DFG is a static representation of the dataflow of a program. It is not a representation of the actual dataflow at runtime.

The Compiler automatically creates DFG files. The DFG files are used by the simulator and scheduler to map onto the actual hardware. DFG files can also be manually created, this section acts as a reference on reading and creating custom DFG files.

## DFG File Format

The dfgfile contains 4 parts:

1. Array Declaration
2. Port Declaration
3. Operation Declaration
4. Meta-level information

We will go through each of these sections seperately.

### Array Declaration

Arrays can be declared with the following Format

`[array-type] <array-name> <size>`

where the array-type can be one of the following:
* `dma` - Direct Memory Access
* `spm` - Scratchpad
* `rec` - Recurrance
* `gen` - Generate
* `reg` - Register

### Port Declaration

Inputs can be declared with the following format:

`Input[Size] <input-name>[<vectorization-degree>] source=<array-name> [stated]`

Correspondingly, Outputs can be declared with the following format:

`Output[Size] <output-name>[<vectorization-degree>] destination=<array-name> [stated]`

Size refers to the datatype size. For instance, Input64 would assume a 64-bit stream while a Input32 would assume a 32-bit stream. If no size is specified, the scheduler will default to creating a 64-bit stream.

Note: The scheduler currently supports decomposible routing. Thus, it can combine different datatypes. However, this is not currently supported by the hardware generator and simulator. Thus, it is recommended to use the same datatype for all streams. We plan to fix this in an upcoming release.

The vectorization degree refers to the number of elements in the stream. For instance, Input64[2] would assume a 64-bit stream with 2 elements. If no vectorization degree is specified, the scheduler will default to creating a 1-element stream.

The source and destination fields refer to the array that the input and output are mapped to. An edge will be created from the specified array to the input/output port.

Stated refers to the first element of the stream being used as a control element within a Operation. By default, ports are not stated and if the 'stated' keyword is specified, the port will be stated.

#### Routing Ports

Port variable names will automatically be created under the format:

`<input/output-name>_<element-number>`

Thus, if we declared a port with the name `foo` and the vectorization degree of 2, the data elements would be named `foo_0` and `foo_1`.

Additionally, the stated element (if the port is stated) will be created under the format:

`<input/output-name>_State`

These variables can be directly used within future operations. Additionally elements can be renamed with the following format:

`<new_name> = <old-name>`

The compiler uses this naming feature to rename the final operation results to the name of the output port. 

#### Optional Port Reuse Pragmas

The compiler automatically generates pragmas describing memory stream reuse information. These pragmas are optional; they are not used in scheduling the DFG to the ADG and only used by the DSE performance models.

The compiler generates the following pragmas for both input and output ports:

`#pragma cmd <cmd-coefficient>`
`#pragma repeat <repeat-rate>`
`#pragma reuse <reuse-rate>`

The cmd coefficient refers to a bound on the memory traffic for a stream, due to a command required to load the data. For instance, in a indirect access stream where the address must be generated by scalar operations, the cmd increases. By default cmd is 1.

The repeat rate refers to the number of times a stream is repeated. For instance, if a stream is used in a loop, the repeat rate is the number of times the loop is executed. By default, the repeat rate is 1.

The reuse rate refers to the number of times a stream is reused by the L2 cache. In the compiler, this is generated by a reuse analysis pass. By default, the reuse rate is 0.

### Operation Declaration and Mapping

Operations can be declared with the following format:

`<operation-result> = <operation-name>(<operation-arguments>)`

where the operation-name can be any operation described within the ISA. The operation-arguments are the inputs to the operation. Each operation argument should be seperated by a comma. The operation-result is the output of the operation.

#### Stated Operation

Operations that utilize the stated control argument have the additional parameter as follows:

`ctrl=$<Port-Name>_State & 8{0: d, 8: r}`

This declares that the result will depend upon the first 8 bits of the stated link.

### Meta-level Information

Each DFG-file can have multiple subgraphs. Each subgraph is seperated by:

`----`

The compiler always produces the first sub-dfg as the array-declaration. Variables within different sub-dfgs should be named seperately and the Arrays are the only variable that can be used across multiple sub-dfgs

Subdfgs have the following optional pragmas:

`#pragma group frequency <code-execution-frequency>`
`#pragma group unroll <vectorization-degree>`

The frequency pragma refers to the code-execution frequency of the sub-dfg. This code frequency will be used by the DSE performance models to determine relative execution time for each sub-dfg. By default, the frequency is 1.

The unroll pragma refers to the vectorization degree of the sub-dfg. This pragma is currently only used when determing recurrance bottleneck. By default, the unroll degree is 1.

The DFG parser also supports comments with lines that are preceded by a hashtag (`#`). The last line of the dfgfile must also be a blank space.

## Example

The following is an example of a DFG file for a non-vectorized add operation:

```
# Declare sub-dfg meta properties
# Frequency is 0 as no work happens in this sub-dfg
#pragma group frequency 0

# Array Declaration
Array array_a 131072 dma
Array array_b 131072 dma

---
# Declare sub-dfg meta properties

#pragma group frequency 255
#pragma group unroll 1

# Port Declaration
Input64 a source=array_a
Input64 b source=array_b

# Operation Declaration
c = add(a, b)

# Output Declaration
Output64 c destination=array_c

```

This produces a dataflow graph that looks like the following:

## Vectorization Example


The following is an example of a DFG file for a vectorized-by-four add operation:

```
# Declare sub-dfg meta properties
# Frequency is 0 as no work happens in this sub-dfg
#pragma group frequency 0

# Array Declaration
Array array_a 131072 dma
Array array_b 131072 dma

---
# Declare sub-dfg meta properties

#pragma group frequency 255
#pragma group unroll 4

# Port Declaration
Input64 a[4] source=array_a
Input64 b[4] source=array_b

# Operation Declaration
c_0 = add(a_0, b_0)
c_1 = add(a_1, b_1)
c_2 = add(a_2, b_2)
c_3 = add(a_3, b_3)

# Output Declaration
Output64 c destination=array_c
```


## More Complex Example

This is an example of a manually programmed DFG for the Stencil-2d workload.

```
# Declare sub-dfg meta properties
# Frequency is 0 as no work happens in this sub-dfg
#pragma group frequency 0


# Array Declaration
Array: a 9248 dma
Array: b 8192 dma

----
# Declare sub-dfg meta properties
# Most of the work happens here so we can set the frequency to 90 or 90%
#pragma group frequency 90
#pragma group unroll 1

# Declare the input ports

#pragma reuse=0.66
Input64: A source=a
#pragma reuse=0.66
Input64: B source=a
#pragma reuse=0.66
Input64: C source=a

# Do the operations
MUL_0A = Mul_I64(A, $Reg0)
MUL_0B = Mul_I64(B, $Reg0)
MUL_0C = Mul_I64(C, $Reg0)

TMPS0 = Add_I64(MUL_0A, MUL_0B)
PSUM0 = Add_I64(MUL_0C, TMPS0)

SHIFT0_REG0 = Add_I64(PSUM0, $Reg0)
SHIFT0_REG1 = Add_I64(SHIFT0_REG0, $Reg0)

MUL_1A = Mul_I64(A, $Reg0)
MUL_1B = Mul_I64(B, $Reg0)
MUL_1C = Mul_I64(C, $Reg0)

TMPS1 = Add_I64(MUL_1A, MUL_1B)
PSUM1 = Add_I64(MUL_1C, TMPS1)

SHIFT1_REG0 = Add_I64(PSUM1, $Reg0)

MUL_2A = Mul_I64(A, $Reg0)
MUL_2B = Mul_I64(B, $Reg0)
MUL_2C = Mul_I64(C, $Reg0)

TMPS2 = Add_I64(MUL_2A, MUL_2B)
PSUM2 = Add_I64(MUL_2C, TMPS2)

PSUM3 = Add_I64(SHIFT0_REG1, SHIFT1_REG0)
O = Add_I64(PSUM3, PSUM2)

# Declare the output ports (there is no reuse)
Output64: O destination=b

----
# Declare sub-dfg meta properties
#pragma group frequency 3

# These are indirect stream generators
Input64: InA source=a
OutA = InA
Output64: OutA destination=a

----
# Declare sub-dfg meta properties
#pragma group frequency 3

# These are indirect stream generators

Input64: InB source=a
OutB = InB
Output64: OutB destination=a

----
# Declare sub-dfg meta properties
#pragma group frequency 3

# These are indirect stream generators

Input64: InC source=a
OutC = InC
Output64: OutC destination=a

```

The resulting dataflow graph looks like the following:

.. toctree::
   :maxdepth: 2